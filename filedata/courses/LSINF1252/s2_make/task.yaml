accessible: true
author: Pablo Gonzalez Alvarez
context: |-
    *Estimated time: 20 minutes*

    ``make`` is a task runner for targets described in a `Makefile`. It is mostly used to control the compilation of an executable from source code. Thus, you can use it to automate the tidious task of compiling your c code, or even automate the compilation of a report made with LaTeX.

    ``make`` a new beginning
    ------------------------

    To give you a first taste, open up a *terminal* and type the following command: ``make``.

    ``make`` will greet you with the following message:

    .. code-block::

        make: *** No targets specified and no makefile found.  Stop.

    So what happened? ``make`` first start to search in your *current directory* for a file called ``Makefile``. This file contains *instructions*, aka *rules*, that tell ``make`` what to do.  Since there is no such file, ``make`` stops almost instantly.

    ``make`` it simple
    ------------------

    Now write a simple hello world program, which you will save into a file called ``hello.c``. This program will print the following on the standard output:

    .. code-block::

         Hello make

    Now, fire up your terminal, use ``cd path/to/hello/folder/`` to go to the directory which contains ``hello.c`` (`download hello.c <https://inginious.info.ucl.ac.be/course/LSINF1252/s2_make/hello.c>`_ to compare with what you did) and type: ``make hello``

    Now the ``make`` comes alive and tells you something like:

    .. code-block::

        gcc     hello.c   -o hello

    Wow! What happened? When you typed ``make hello``, ``hello`` is what is called a **target**. A **target** is usually the name of a file that is generated by a program; examples of targets are executable or object files.

    Basically, ``make`` will search for a file named ``hello`` and detect from that file what programming language it uses. For most languages, ``make`` has some basic builtin recipes, called **implicit rules**, to compile it. Here the **recipe** is given in the above output.

    In that output:

    * ``gcc`` stands for *GNU C Compiler*;
    * ``hello.c`` the C program to be compiled;
    * ``-o hello`` an option to place the output of the compilation in the file ``hello``.

    Now if you type ``ls`` in your command line, you will see that a file ``hello`` appeared. This is the **executable** built by ``make`` from ``hello.c``. Now you can execute it and verify what is printed on the standard output.

    If you type again ``make hello`` in your command line, it will tell you:

    .. code-block::

        make: 'hello' is up to date.

    That is because ``make`` only builds the files that are changed. If ``hello`` is more recent than its source file ``hello.c``, ``make`` will skip the compilation process.

    To see this, modify ``hello.c`` to write the following on the standard output:

    .. code-block::

        Hello, make!

    Finally, run ``make hello`` again. Since ``hello.c`` is more recent than ``hello``, ``make`` will compile the source file again.

    Thats it, you made your first experiences with ``make``.

    Now I strongly recommend you read `sections 2.1 to 2.3. in the GNU make manual <https://www.gnu.org/software/make/manual/make.html#Introduction>`_. It will only take you 10 minutes (included in the above given estimated time) and will help you understand how to ``make`` magic happen.

    Once you read these 3 sections, let us practice a bit.

    To try the following questions locally, you can download a zip file of the questions folder `here <https://inginious.info.ucl.ac.be/course/LSINF1252/s2_make/make_me.zip>`_.

    ----

    References
    ----------

    * https://sites.uclouvain.be/SystInfo/notes/Outils/html/make.html
    * https://www.gnu.org/software/make/manual/
environment: cpp
evaluate: best
groups: false
limits:
    time: '30'
    output: '2'
    memory: '100'
name: '[S4] make basics '
network_grading: false
order: 40
problems:
    make_me_easy:
        type: match
        answer: make make_me
        header: |-
            After typing ``ls`` in your terminal, you see the following folder structure:

            .. code-block:: console

                make_me.c       make_me.h

            You want to build an executable ``make_me`` from the above source thanks to ``make``. What do you type in the terminal to do that?

            **Hint:** you do not need to write a *Makefile*.
        name: Make me easy
    make_me_less_easy:
        language: Makefile
        header: |-
            Suppose you cannot use what you did in the above question. Write a Makefile that compiles the above given code and builds an executable ``make_me``. You can reuse the ``Makefile`` given in the above given zip file.

            **Hint:** If you have no idea where to start, read `sections 2.1 to 2.3. in the GNU make manual <https://www.gnu.org/software/make/manual/make.html#Introduction>`_.
        type: code
        name: Make me less easy
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags:
    '0':
        type: 0
        name: make & Makefile
        id: make
        description: Tasks related to the make task runner for targets described in
            Makefile.
        visible: true
    '1':
        type: 2
        visible: true
        name: S2
        description: ''
        id: ''
weight: 1.0
